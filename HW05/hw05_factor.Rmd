---
title: 'Exercise 5: Factor and figure management'
author: "Tracy Wang"
date: "10/11/2019"
output: html_document
---

## Exercise 1: Explain the value of the here::here package

*Read through the blog post by Malcolm Barrett where he outlines why one should use the here::here package in RStudio projects.*

*Task: In your own words, summarize the value of the here::here package in 250 words or fewer.*

The `here::here` package is useful for setting relative paths for the working directory of your project, especially when said project is shared among multiple users. 

- Not all users' local directories will have the same structure. If one were to set the working directory using `setwd()` then the working directory would have to be changed every time a different local computer was used. 
- Different operating systems use different notations to separate folders. For example, Mac computers do/it/this/way whereas Windows OS does\things\another\way. Whenever the project gets accessed from a different OS, the user would have to replace the slashes with backslashes, or vice versa. 
- This process is tedious and time-consuming to have to repeat all the time. And just imagine if you make a typo...

In a nutshell, `here::here` makes a project much more versatile for sharing. It makes navigating sub-directories easier, too.

- When retrieving files from another subdirectory, rather than having to backtrack to the parent directory and locate it from there, you can use `here()` to call directly on the sub-directory if it's in your root folder.
- It is possible to set a separate working directory within the project and still have `here()` work because project directories take precedence.

```{r}
library(singer)
library(tidyverse)
library(DT)
library(knitr)
```


## Exercise 2: Factor management

*Task: Choose one dataset (of your choice) and a variable to explore. After ensuring the variable(s) you’re exploring are indeed factors, you should:*

- *Drop factor / levels;*
- *Reorder levels based on knowledge from data.*

*We’ve elaborated on these steps for the gapminder and singer data sets below.*

*Explore the effects of re-leveling a factor in a tibble by:*

- *comparing the results of arrange on the original and re-leveled factor.*
- *Plotting a figure of before/after re-leveling the factor (make sure to assign the factor to an aesthetic of your choosing).*

*These explorations should involve the data, the factor levels, and at least two figures (before and after).*

I have chosen to use the Singer dataset.

*__Elaboration for the Singer data set__*

*If necessary, transform some of the variables in the singer_locations dataframe into factors: pay attention at what levels you introduce and their order.*

*Drop 0. Filter the singer_locations data to remove observations associated with the uncorrectly inputed year 0. Additionally, remove unused factor levels. Provide concrete information on the data before and after removing these rows and levels; address the number of rows and the levels of the affected factors.*

*Reorder the levels of year, artist_name or title. Use the forcats package to change the order of the factor levels, based on a principled summary of one of the quantitative variables. Consider experimenting with a summary statistic beyond the most basic choice of the median.*

### Drop factors/levels

First, let's look at `singer_locations` without modifications. The dataframe contains 10,100 entries, which apparently is too much for `datatable()` to handle as a client-side operation (!), so I won't be presenting it as a tibble.

```{r}
singer_all <- singer_locations %>% 
    mutate(year = as_factor(year))

singer_all$year %>% 
    str()
```

The above output shows us that `year` has now been converted to a factor class object, with 70 levels (different values) of year present in the dataframe. We can also see some instances of integers that these levels are stored as.

```{r}
singer_all

```

There are 10,100 rows of data in this dataframe.

Now let's filter out those `year = 0` entries.

```{r}
singer_filter <- singer_all %>% 
    filter(year!=0)

singer_filter

singer_filter$year %>% 
    str()
```

Without using `droplevels()`, there are still 70 levels present, despite all instances of `year = 0` having been filtered out. However, the number of entries in the dataframe has decreased to 10,000.

```{r}
singer_drop <- singer_filter %>% 
    droplevels()

singer_drop

singer_drop$year %>% 
    str()
```

Now that the level 0 is dropped, `year` has 69 levels total. The number of entries remains the same as in the previous step.

### Re-order levels (by year)

To simplify our plot, let's recategorize years into decades.

```{r}
(singer_fct <- singer_locations %>% 
    filter(year != 0) %>% 
    mutate(decade = cut(year, breaks = c(1919, 1929, 1939, 
                                         1949, 1959, 1969, 
                                         1979, 1989, 1999, 
                                         2009, 2019),
                               labels = c("1920s", "1930s", 
                                          "1940s", "1950s", 
                                          "1960s", "1970s", 
                                          "1980s", "1990s", 
                                          "2000s", "2010s"))))

singer_fct$decade %>% 
    nlevels()

```

There are 10 levels in the `decade` factor. 

On to some graphs!

```{r}
# Box plot of song durations by decade
singer_fct %>%     
    ggplot() + 
    geom_boxplot(aes(x=decade, y=duration))
```

We can see that the durations of songs varies greatly, with some of the longest songs being around 2000 seconds.

Here is the number of songs listed for each decade:

```{r}
# Number of songs in each decade, default arrangement
singer_fct %>% 
    ggplot() +
    geom_bar(aes(decade)) + 
    scale_x_discrete(drop=FALSE) +
    scale_y_log10() 
```

By default, the levels happen to be arranged in chronological order. 

Note that a single instance of 1930s music does exist in this dataframe, but ggplot got upset about forcing the y-axis to start at 0 using `expand_limits()`. A linear y-axis scale will be used for subsequent plots.

```{r}
singer_fct %>% 
    count(decade) %>% 
    kable()
```

The follow bar graph shows the same info, but arranged in order of most to fewest songs listed per decade.

```{r}
# Number of songs in each decade, arranged by count
singer_fct %>% 
    ggplot() +
    geom_bar(aes(fct_rev(fct_infreq(decade)))) +
    coord_flip()
```

Let's order the song count by maximum duration per decade, starting with the longest:

```{r}
# Number of songs in each decade, arranged by maximum song duration for that decade (ascending).
singer_fct %>% 
    ggplot() +
    geom_bar(aes(fct_rev(fct_reorder(decade, duration, max))))
```

This corresponds with the tabulated data below.

```{r}
singer_fct %>% 
    group_by(decade) %>% 
    summarize(longest=max(duration)) %>% 
    arrange(desc(longest)) %>% 
    kable()
```



## Exercise 3: File input/output (I/O)

*Task: Experiment with at least one of:*

- *write_csv()/read_csv() (and/or TSV friends),*
- *saveRDS()/readRDS(),*
- *dput()/dget().*

*You are expected to create something new, probably by filtering or grouped-summarization of your dataset (for e.g., Singer, Gapminder, or another dataset), export it to disk and then reload it back in using one of the packages above. You should use here::here() for reading in and writing out.*

*With the imported data, play around with factor levels and use factors to order your data with one of your factors (i.e. non-alphabetically). For the I/O method(s) you chose, comment on whether or not your newly created file survived the round trip of writing to file then reading back in.*

Let's write our factored singer_locations dataframe from Exercise 2 to file. We'll keep only songs from the 1990s to trim down the dataframe size a little.

```{r}
library(here)
dr_here()

(singer_out <- singer_fct %>% 
    filter(decade == "1990s"))

write_csv(singer_out, here::here("HW05", "singer_fct.csv"))

```

```{r load_csv, warning=FALSE}
(singer_load <- read_csv(here::here("HW05", "singer_fct.csv")))

```

We can see that our `decade` column is parsed as character class instead of factor.

```{r}
singer_load %>% 
    mutate(year=as_factor(year)) %>% 
    ggplot() + geom_bar(aes(fct_infreq(year)))
```



```{r}
dput(singer_out, file = here::here("HW05", "singer_fct_d.csv"),
     control = c("keepNA", "keepInteger", "niceNames", "showAttributes"))

```

The file has been successfully written but the format is different than `write_csv()`'s output. If we try and retrieve the file using `read_csv()`...

```{r}

read_csv(here::here("HW05", "singer_fct_d.csv"))

```

Whoops, a lot of parsing errors occurred!

```{r}

dget(here::here("HW05", "singer_fct_d.csv"), keep.source = TRUE)
```

In this case, the factor class of `decade` actually made it through the wringer. When the file is retrieved and parsed, it's still a factor. 

```{r}
(singer_first <- singer_load %>% 
    drop_na() %>% 
    group_by(firstletter = as_factor(substr(name, 1, 1))))

singer_first %>% 
    ggplot() + geom_boxplot(aes(x=firstletter, y=artist_familiarity))
```



## Exercise 4: Visualization design (20%)

*Go back through your previous assignments and class participation activities and find figures you created prior to the last week of the course. Recreate at least one figure in light of something you learned in the recent class meetings about visualization design and color.*

*Task: Create a side-by-side plot and juxtapose your first attempt (show the original figure as-is) with a revised attempt after some time spent working on it and implementing principles of effective plotting principles. Comment and reflect on the differences.*



## Exercise 5: Writing figures to file (10%)

Task: Use ggsave() to explicitly save a plot to file. Include the exported plot as part of your repository and assignment.

Then, use ![Alt text](/path/to/img.png) to load and embed that file into your report. You can play around with various options, such as:

    Arguments of ggsave(), such as width, height, resolution or text scaling.
    Various graphics devices, e.g. a vector vs. raster format.
    Explicit provision of the plot object p via ggsave(..., plot = p). Show a situation in which this actually matters.
    
<!--- Old code, rejected for tedious repetition
```{r}
singer_fct <- singer_locations %>% 
    filter(year != 0) %>% 
    mutate(decade = factor(case_when(year < 1920 ~ "1910s",
                                     year < 1930 ~ "1920s",
                                     year < 1940 ~ "1930s",
                                     year < 1950 ~ "1940s",
                                     year < 1960 ~ "1950s",
                                     year < 1970 ~ "1960s",
                                     year < 1980 ~ "1970s",
                                     year < 1990 ~ "1980s",
                                     year < 2000 ~ "1990s",
                                     year < 2010 ~ "2000s",
                                     TRUE ~ "2010s"), 
                           levels = c("1910s", "1920s", 
                                      "1930s", "1940s", 
                                      "1950s", "1960s", 
                                      "1970s", "1980s", 
                                      "1990s", "2000s", 
                                      "2010s")))

```
-->
